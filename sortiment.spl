#!/usr/bin/env splrun

load "file";
load "system";

var data;
var order;
var order_parts;
var order_provider;
var index;

var link_rules;
var mwst_rules;

function help()
{
	debug "Usage: splrun sortiment.spl { wikitext | labelcsv | orderwiki | kastenwiki | folder | invsum }";
	exit;
}

if (not declared argc or argc != 1)
	help();

/* input file parser (sortiment) */
{
	var current_cat;
	var current_item;
	var current_extra;
	var last_ent;

	var idx_lieferant;
	var idx_ekprice;
	var idx_ekpstk;
	var idx_vpe;

	foreach[] line (file_read("sortiment.txt") =~ /\n+/Sg)
	{
		if (line =~ /^\s*$/ or line =~ /^\//)
			continue;

		if (line =~ /^\*\s*(.*\S)/) {
			foreach[] t ($1 =~ /\s*\|\|\s*/Sg)
				push data[current_cat].base_titles, t;
			last_ent = "*";
			continue;
		}

		if (line =~ /^\.*\s*\|\|\s*(.*\S)/ and last_ent ~== "*") {
			var list_txt = "$1 || EKP/Stk";
			foreach[] t (list_txt =~ /\s*\|\|\s*/Sg) {
				push data[current_cat].extra_titles, t;
				if (t ~== "Lieferant")
					idx_lieferant = prev data[current_cat].extra_titles, undef;
				if (t ~== "EK-Preis")
					idx_ekprice = prev data[current_cat].extra_titles, undef;
				if (t ~== "EKP/Stk")
					idx_ekpstk = prev data[current_cat].extra_titles, undef;
				if (t ~== "VPE")
					idx_vpe = prev data[current_cat].extra_titles, undef;
			}
			last_ent = undef;
			continue;
		}

		if (line =~ /^\+\s*(.*\S)/) {
			current_item++;
			current_extra = -1;
			data[current_cat].items[current_item] = [ base: undef, extra: undef, links: undef ];
			foreach[] t ($1 =~ /\s*\|\|\s*/Sg) {
				if ($[ and declared index[t])
					panic "Duplicate Index: $t";
				if ($[)
					index[t] = data[current_cat].items[current_item];
				push data[current_cat].items[current_item].base, t;
			}
			last_ent = "+";
			continue;
		}

		if (line =~ /^\.*\s*\|\|\s*(.*\S)/ and last_ent ~== "+") {
			current_extra++;
			data[current_cat].items[current_item].extra[current_extra] = undef;
			var curr_e_ptr = data[current_cat].items[current_item].extra[current_extra];
			foreach[] t ($1 =~ /\s*\|\|\s*/Sg)
				push curr_e_ptr, t;
			if (declared mwst_rules[curr_e_ptr[idx_lieferant]]) {
				curr_e_ptr[idx_ekprice] =~ e/([0-9,]+)/ ({ var price = $1 =~ s/,/./Rg;
						price += price .* mwst_rules[curr_e_ptr[idx_lieferant]] ./ 100;
						return fmt("%.03f", price) =~ s/\./,/Rg; });
			}
			if (declared curr_e_ptr[idx_vpe] and declared curr_e_ptr[idx_ekprice]) {
				var ekprice = curr_e_ptr[idx_ekprice];
				ekprice =~ s/,/./g; ekprice =~ s/ EUR//;
				var vpe = curr_e_ptr[idx_vpe];
				vpe =~ s/.*x//;
				var ekpstk = ekprice ./ vpe;
				curr_e_ptr[idx_ekpstk] = fmt("%.03f EUR", ekpstk) =~ s/\./,/Rg;
			}
			continue;
		}

		last_ent = undef;

		if (line =~ /^!\s*(.*\S)/) {
			current_cat = $1;
			current_item = -1;
			if (declared data[current_cat])
				panic "cat dup in line ${$#+1}: $current_cat";
			data[current_cat] = [
				description: undef,
				base_titles: undef,
				extra_titles: undef,
				has_links: 0,
				variables: undef,
				items: undef
			];
			continue;
		}

		if (line =~ /^\?\s*(.*)/) {
			data[current_cat].description ~= "$1\n";
			continue;
		}

		if (line =~ /^:\s*(\S+)\s+(\S+.*)/) {
			push data[current_cat].items[current_item].links, [ "http://svn.clifford.at/metaparts/trunk/datasheets/DS_${system("echo '$1' | md5sum | cut -f1 -d' '")}.html", $2 ];
			data[current_cat].has_links = 1;
			continue;
		}

		if (line =~ /^:\s*(\S+)/) {
			push data[current_cat].items[current_item].links, [ "http://svn.clifford.at/metaparts/trunk/datasheets/DS_${system("echo '$1' | md5sum | cut -f1 -d' '")}.html", "Datasheet" ];
			data[current_cat].has_links = 1;
			continue;
		}

		if (line =~ /^\=(\S+):\s*(.*)/) {
			data[current_cat].variables[$1] = $2;
			continue;
		}

		if (line =~ /^@linkrule@\s*(.*?)\s*\|\|\s*(.*\S)/) {
			push link_rules, [ cond: $1, url: $2 ];
			continue;
		}

		if (line =~ /^@mwstrule@\s*(.*?)\s*\|\|\s*(\d+)%/) {
			mwst_rules[$1] = $2;
			continue;
		}

		panic "syntax error in line ${$#+1}: $line";
	}
}

/* input file parser (order) */
{
	var provider;

	foreach[] line (file_read("order.txt") =~ /\n+/Sg)
	{
		if (line =~ /^\s*$/ or line =~ /^\//)
			continue;

		if (line =~ /^==(.*)==$/) {
			provider = $1;
			order_provider[provider] = 1;
			continue;
		}

		if (line =~ /^(\d+)x(\d+)\s+(.*\S)/) {
			var num = $1, vpe = $2;
			foreach[] part ($3 =~ /\s+/Sg) {
				push order, [ provider: provider, num: num, vpe: vpe, part: part ];
				order_parts[part][provider][vpe] = num;
			}
			continue;
		}

		panic "syntax error in line ${$#+1}: $line";
	}
}

if (argv[0] ~== "wikitext")
{
	write(<:>
		: ==Bauteile==
		: <!-- Auto-generated by sortiment.spl - do not manually change this section! -->
	</>);
	foreach[] c (data)
	{
		var links_header = c.has_links ? "! Links !" : "";
		write(<:>
			:
			: ===$#===
			: <!-- Auto-generated by sortiment.spl - do not manually change this section! -->
			: ${c.description}
			: {|border="1" cellpadding="5" cellspacing="0" style="text-align:right; width:100%;"
			: <spl:foreach var="[]t" list="c.base_titles">! $t !</spl:foreach>$links_header$[
			 ]<spl:foreach var="[]t" list="c.extra_titles">! $t<spl:if code="not $]"> !</spl:if></spl:foreach>
		</>);

		var dark_mode = 0;
		var order_lines = 0;
		var last_order_sig;
		var lines;
		foreach[] i (c.items)
		foreach[] e (i.extra)
		{
			var this_line_data;
			foreach idx (c.base_titles) {
				this_line_data[c.base_titles[idx]] = i.base[idx];
			}
			foreach idx (c.extra_titles) {
				this_line_data[c.extra_titles[idx]] = e[idx];
			}
			function get_field_text(name) {
				var value = this_line_data[name];
				foreach[] r (link_rules) {
					if (name ~== "Bestell-Nr." and this_line_data["Lieferant"] ~== r.cond) {
						var url = (r.url =~ e/\{(\S+)\}/R this_line_data[$1]) =~ s/ /+/Rg;
						value = "[$url $value]";
					}
				}
				return value;
			}
			var links_text = "";
			foreach[] l (i.links) {
				links_text ~= "[${l[0]} ${l[1]}]";
				if (!$])
					links_text ~= ", ";
			}
			if (c.has_links)
				links_text = "| $links_text |";
			var common_part = <:>
				: <spl:foreach var="[]v" list="c.base_titles">| ${get_field_text(v)} |</spl:foreach>$links_text$[
			]</>;
			if ($# > 0)
				common_part =~ s/[^ |]/ /g;
			else
				dark_mode = !dark_mode;
			var extra_color = "#888";
			var this_line_vpe = this_line_data["VPE"];
			var this_line_min = 1;
			if (this_line_vpe =~ /([0-9]+)x([0-9]+)/ ) {
				this_line_min = $1;
				this_line_vpe = $2;
			}
			var order_sig = "${this_line_data["Fach"]}|${this_line_data["Lieferant"]}|${this_line_data["Bestell-Nr."]}";
			if (declared order_parts[this_line_data["Fach"]] and
					declared order_parts[this_line_data["Fach"]][this_line_data["Lieferant"]] and
					declared order_parts[this_line_data["Fach"]][this_line_data["Lieferant"]][this_line_vpe] and
					order_parts[this_line_data["Fach"]][this_line_data["Lieferant"]][this_line_vpe] >= this_line_min) {
				if (last_order_sig ~== order_sig)
					lines[prev lines, undef] =~ s/color:#E45712/color:#888/g;
				extra_color = "#E45712";
				order_lines = 1;
			}
			last_order_sig = order_sig;
			push lines, <:>
				: |- ${dark_mode ? 'style="background:#ccc;"' : ''}
				: ${common_part}<spl:foreach var="[]v" list="c.extra_titles">|style="color:$extra_color"| ${get_field_text(v)}<spl:if code="not $]">${" "}|</spl:if></spl:foreach>
			</>;
		}

		write(<:>
			<spl:foreach var="[]l" list="lines">$l</spl:foreach>
			: |}
			<spl:if code="order_lines">
			: <div align="right"><small>Orangene Eintraege sind zur Nachbestellung vorgemerkt.</small></div>
			</spl:if>
		</>);
	}

	exit;
}

if (argv[0] ~== "labelcsv")
{
	write("fach;title;extra;price\n");
	foreach[] c (data)
	foreach[] i (c.items)
	{
		var fach = i.base[0];
		var title = (c.variables["title"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		var extra = (c.variables["extra"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		var price = (c.variables["price"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		write("$fach;$title;$extra;$price\n");
	}
	exit;
}

if (argv[0] ~== "orderwiki")
{
	var wikitext;
	var bigtotal = 0.0;
	var order_ok;
	foreach p (order_provider)
	{
		var ordercode;
		var linecount = 1;
		var total = 0.0;
		wikitext ~= <:>
			:
			: ===${p ~== "???" ? "Bestellung Ohne Zugewiesenem Lieferanten" : p}===
			: <!-- Auto-generated by sortiment.spl - do not manually change this section! -->
			: {|border="1" cellpadding="5" cellspacing="0" style="text-align:right;width:100%;"
			: ! Fach !! Beschreibung !! Anzahl <spl:if code="p ~!= '???'">!! VPE !! Bestell-Nr. !! Einzel-Preis !! Preis</spl:if>
		</>;
		if (p ~== "CSD" or p ~== "DigiKey" or p ~== "SmartPrj" or p ~== "Ribu" or p ~== "Watterott" or p ~== "Futurlec" or p ~== "Conrad")
			ordercode ~= <:>
				:  ${fmt("%5s  %5s  %5s  %8s  %20s  %s",
						"Num", "VPE", "Total", "Price", "Best-Nr.", "Beschreibung")}
				:  ${fmt("%5s  %5s  %5s  %8s  %20s  %s",
						"---", "---", "-----", "-----", "--------", "------------")}
			</>;
		foreach[] c (data)
		foreach[] i (c.items)
		foreach[] e (i.extra)
		{
			var part = i.base[0];
			var provider, vpe, partid, price;
			var title = (c.variables["title"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
			foreach[] t (c.extra_titles) {
				if (t ~== "Lieferant")
					provider = e[$#];
				if (t ~== "VPE")
					vpe = e[$#];
				if (t ~== "Bestell-Nr.")
					partid = e[$#];
				if (t ~== "EK-Preis")
					price = e[$#];
			}
			price =~ s/,/./g;
			price =~ s/\s+EUR//g;
			if (p ~!= provider and p ~!= "???")
				continue;
			foreach[] o (order) {
				if (o.part ~!= part)
					continue;
				if (p ~!= "???") {
					if (o.provider ~!= provider)
						continue;
					if (o.vpe ~!= vpe and !(vpe =~ /([0-9]+)x([0-9]+)/ && o.num >= $1 && o.vpe ~== $2))
						continue;
				}
				order_ok[$#] = [
					o: o,
					provider: p,
					title: title,
					partid: partid,
					price: p ~!= "???" ? price : 0
				];
			}
		}

		foreach[] x (order_ok)
		{
			if (x.provider ~!= p)
				continue;
			var o = x.o;
			wikitext ~= <:>
				: |- ${linecount % 2 ? 'style="background:#ccc;"' : ''}
				: | $o.part
				: | $x.title
				<spl:if code="p ~!= '???'">
				: | $o.num
				: | $o.vpe
				: | $x.partid
				: | ${x.price =~ s/\./,/R} EUR
				: | ${fmt("%.02f", x.price*o.num) =~ s/\./,/R} EUR
				</spl:if><spl:else>
				: | ${o.num * o.vpe}
				</spl:else>
			</>;
			if (p ~== "RS")
				ordercode ~= <:>
					:  $x.partid,$o.num
				</>;
			else if (p ~== "Reichelt")
				ordercode ~= <:>
					:  $x.partid;$o.num
				</>;
			else if (p ~== "CSD" or p ~== "DigiKey" or p ~== "SmartPrj" or p ~== "Ribu" or p ~== "Watterott" or p ~== "Futurlec" or p ~== "Conrad")
				ordercode ~= <:>
					:  ${fmt("%5d  %5d  %5d  %8.2f  %20s  %s",
							o.num, o.vpe, o.num*o.vpe,
							x.price*o.num, x.partid, x.title)}
				</>;
			else if (p ~== "???")
				/* do nothing */;
			else
				panic "Can not generate ordercode for supplier '$p'.";
			total += x.price*o.num;
			bigtotal += x.price*o.num;
			linecount++;
		}
		wikitext ~= <:>
			<spl:if code="p ~!= '???'">
			: |- ${linecount % 2 ? 'style="background:#ccc;"' : ''}
			: |colspan="6"|Total
			: | ${fmt("%.02f", total) =~ s/\./,/R} EUR
			</spl:if>
			: |}
			<spl:if code="defined ordercode">
			:
			: Code zum Bestellen ueber die Lieferantenhomepage:
			: $ordercode</spl:if>$[
		]</>;
		var not_ok_list;
		foreach[] o (order) {
			if (o.provider ~!= p)
				continue;
			if (declared order_ok[$#])
				continue;
			not_ok_list ~= <:>
				:  ${o.num}x${o.vpe} ${o.part}
			</>;
		}
		if (defined not_ok_list) {
			wikitext ~= <:>
				:
				: Unable to handle the following parts:
				:  ==${p}==
				: $not_ok_list$[
			]</>;
		}
	}
	write(<:>
		: ==Naechste Bestellung==
		: <!-- Auto-generated by sortiment.spl - do not manually change this section! -->
		:
		: Dieser Abschnitt beinhaltet den derzeitigen Stand der naechsten geplanten Bestellung.
		:
		: Kontakt fuer Bestellabwicklung (z.Bsp. bei dringendem Bedarf an nachgekauften Bauteilen):
		: Astrid und Clifford
		:
		: ACHTUNG: Die tatsaechlichen Preise koennen abweichen, da Mengenrabatte nicht beruecksichtigt
		: werden und die Preise beim Lieferanten sich inzwischen veraendert haben koennen.
		:
		: Gesamtbestellwert: ${fmt("%.02f", bigtotal) =~ s/\./,/R} EUR
		: $wikitext
	</>);
	exit;
}

if (argv[0] ~== "kastenwiki")
{
	var fach_text;
	foreach[] c (data)
	foreach[] i (c.items)
	{
		var fach = i.base[0] =~ s/\..*//R;
		var title = (c.variables["title"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		var extra = (c.variables["extra"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		var price = (c.variables["price"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		fach_text[fach] = <:>
			: <b>$title</b><br/>$extra<br/>
			: <div style="float:left">$fach</div>
			: <div style="float:right">$price</div>
		</>;
	}
	function fach(id)
	{
		return defined fach_text[id] ? fach_text[id] : id;
	}
	write(<:>
		: == Kastenplan ==
		: <!-- Auto-generated by sortiment.spl - do not manually change this section! -->
	  <spl:var var="table_style">border-color:blue; border-style:solid; border-width:2px; font-size:70%; width:100%;</spl:var>
	  <spl:var var="td_style">border-color:blue; border-style:solid; border-width:5px; height:10em; padding-left:1em; padding-right:1em; text-align:center;</spl:var>
	  <?spl foreach[] kasten ([1, 2, 3, 4, 5, 6]) { ?>
		:
		: ===Kasten $kasten===
		: <!-- Auto-generated by sortiment.spl - do not manually change this section! -->
		: {| style="$table_style"
	    <?spl foreach[] row ((kasten >= 3 ? kasten >= 5 ? "1234567" : "ABCDEFGHIJKL" : "MNOPQRS") =~ /./Ag) { ?>
		: |-
	      <?spl for (var column=0; column<5; column++) { ?>
		: |style="$td_style width:20%;" colspan="2"|${fach('$row${kasten % 2 == 1 ? column : column+5}')}
	      <?spl } ?>
	    <?spl } ?>
	    <?spl if (kasten <= 2 || kasten >= 5) { ?>
		: |-
		: |style="$td_style width:50%;" colspan="5"|${fach('${kasten >= 5 ? '8' : 'T'}${kasten % 2 == 1 ? 1 : 6}')}
		: |style="$td_style width:50%;" colspan="5"|${fach('${kasten >= 5 ? '8' : 'T'}${kasten % 2 == 1 ? 3 : 8}')}
		: |-
		: |style="$td_style" colspan="10"|${fach('${kasten >= 5 ? '9' : 'U'}${kasten % 2 == 1 ? 2 : 7}')}
	    <?spl } ?>
		: |}
	  <?spl } ?>
	</>);
	exit;
}

if (argv[0] ~== "folder")
{
	var texsrc = "";

	function encode_tex(t) {
		t =~ s/\\/\\textbackslash{}/g;
		t =~ s/~/\\textasciitilde{}/g;
		t =~ s/\^/\\textasciicircum{}/g;
		t =~ s/(?<!textbackslash|textbackslash\{|$[
			]textasciicircum|textasciicircum\{|$[
			]textasciitilde|textasciitilde\{$[
			])[_&$#{}\^%]/\\$0/g;
		t =~ s/([<>]|--+)/\$$1\$/g;
		return t;
	}

	foreach[] c (data)
	{
		if ($# ~== "Widerstaende (Axiale Bauform)")
			continue;

		if ($# ~== "Widerstaende (Axial, Niederohm)")
			continue;

		texsrc ~= <:>
			: \section{$#}
			: \begin{tabular}{<spl:foreach var="[]t" list="c.base_titles">|r</spl:foreach>|}
			: \hline
			: <spl:foreach var="[]t" list="c.base_titles"><spl:if code="not $[">${" & "}</spl:if>${tex::t}</spl:foreach> \\
			: \hline
		</>;

		var lines;
		foreach[] i (c.items)
		{
			var this_line_data;
			foreach idx (c.base_titles) {
				this_line_data[c.base_titles[idx]] = i.base[idx];
			}
			texsrc ~= <:>
				: <spl:foreach var="[]v" list="i.base"><spl:if code="not $[">${" & "}</spl:if>${tex::v}</spl:foreach> \\
				: \hline
			</>;
		}

		texsrc ~= <:>
			: \end{tabular}
		</>;
	}

	write(<:>
		: \documentclass[a4paper]{article}
		: \begin{document}
		: \title{Bauteilsortiment}
		: \author{Kontakt: Clifford Wolf, clifford@clifford.at\\
		: http://metalab.at/wiki/Bauteilsortiment}
		: \maketitle

		: \section{Einfuehrung}
		: \begin{itemize}
		: \item Preis laut Etiketten bzw. dieser Liste in die Kasse
		: einwerfen.
		: \item Entnommene Bauteile nicht wieder zuruecklegen.
		: \item Nicht eingenmaechtig einsortieren.
		: \item Geld wechseln bei der Kasse in der Kueche.
		: \item Spenden helfen dem Bauteilsortiment beim expandieren.
		: \end{itemize}

		$texsrc

		: \end{document}
	</>);
	exit;
}

if (argv[0] ~== "invsum")
{
	var inv_hash;
	var total_sum = 0;
	var partcount = 0;

	foreach[] line (file_read("inventur.txt") =~ /\n+/Sg)
	{
		if (line =~ /^(\S+).*\s([0-9]+)\s*$/)
			inv_hash[$1] = +$2;
	}
	
	foreach[] c (data)
	foreach[] i (c.items)
	{
		var fach = i.base[0];
		var title = (c.variables["title"] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		var pricevar = declared c.variables["xprice"] ? "xprice" : "price";
		var price = (c.variables[pricevar] =~ e/\[(\d+)\]/Rg i.base[$1]) =~ s/ +/ /Rg;
		price =~ s/ EUR//; price =~ s/,/./;
		var num = declared inv_hash[fach] ? inv_hash[fach] : "-";
		var total = declared inv_hash[fach] ? price*num : "-";
		write("$fach\t$total\t$num\t$price\t$title\n");
		total_sum += total;
		partcount += num;
	}

	write("****\t$total_sum\t$partcount\n");

	exit;
}

help();

